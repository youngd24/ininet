#!/usr/bin/env python3
# Merged STARTING SCREEN + Tic-Tac-Toe game
# Features preserved:
# - 0/1/2 players (AI vs AI / Human vs AI / Human vs Human)
# - Optional per-move AI delay (-d)
# - 2s pause between AI-vs-AI games
# - Running leaderboard (X/O wins, draws)
# - Stop after 10 total draws -> WOPR quote + "how about a nice game of chess (Y/N)" then exit
# - Mix of CLI flags and interactive prompts
#
# Usage examples:
#   python3 wopr_ttt.py                 # show menu, secret "tic tac toe" starts game
#   python3 wopr_ttt.py -p 0 -d 1       # menu first; AI vs AI with 1s per move after secret entered
#   python3 wopr_ttt.py -p 1 -c O       # menu first; Human (O) vs Computer

import argparse
import os
import re
import signal
import sys
import time
import time
import random


# ---- Speed presets (seconds; includes jitter so effect is visible) ----
# Format: (char_min, char_max, line_min, line_max)
PRESETS = {
    "9600": (0.0008, 0.0025, 0.03, 0.10),
    "2400": (0.0025, 0.0060, 0.06, 0.20),
    "1200": (0.0060, 0.0120, 0.10, 0.30),
    "300":  (0.0300, 0.1200, 0.20, 0.50),
    "fast": (0.0002, 0.0008, 0.02, 0.06),
}

# Defaults (~9600-ish feel)
SP_CHAR_MIN, SP_CHAR_MAX, SP_LINE_MIN, SP_LINE_MAX = PRESETS["9600"]


# -------------------- Starting Screen --------------------
MENU = """(C) PROTOVISION COMPUTERS 1979-1983
LAST LOGIN 14/04/83 23:36

CHECKERS
CHESS
POKER
FIGHTER COMBAT
GUERILLA COMBAT
DESERT WARFARE
AIR-TO-GROUND ACTIONS
THEATERWIDE TACTICAL WARFARE
THEATERWIDE BIOTOXIC AND CHEMICAL WARFARE

GLOBAL THERMONUCLEAR WAR
"""

# Regex: any combination of the words "tic", "tac", "toe" separated by spaces (case-insensitive)
TIC_TAC_TOE_RE = re.compile(r'^(?:tic|tac|toe)(?:\s+(?:tic|tac|toe))*$', re.IGNORECASE)

def handle_interrupt(signum, frame):
    print("\nINTERRUPT CAUGHT, EXITING...")
    sys.exit(0)

signal.signal(signal.SIGINT, handle_interrupt)

# -------------------- CLI for the game --------------------
def parse_args():
    p = argparse.ArgumentParser(add_help=False)
    p.add_argument("-p", choices=["0", "1", "2"], help="Human players: 0, 1, or 2. Default 2")
    p.add_argument("-c", choices=["X", "O"], help="Your mark when -p 1 (X or O). Default X")
    p.add_argument("-d", type=int, help="Delay (seconds) between AI moves. Default 0")
    p.add_argument("-h", "--help", action="help", help="Show this help message and exit")
    return p.parse_args()

# -------------------- Game Engine --------------------
X = "X"
O = "O"

class Leaderboard:
    def __init__(self):
        self.games = 0
        self.w_x = 0
        self.w_o = 0
        self.draws = 0
        self.draw_limit = 3

    def record_win(self, mark):
        self.games += 1
        if mark == X:
            self.w_x += 1
        else:
            self.w_o += 1

    def record_draw(self):
        self.games += 1
        self.draws += 1

    def print_board(self):
        total = self.games
        print(f"\n=== LEADERBOARD (MARKS) — GAMES: {total} ===")
        print(f"X — WINS: {self.w_x} | LOSSES: {self.w_o} | DRAWS: {self.draws}")
        print(f"O — WINS: {self.w_o} | LOSSES: {self.w_x} | DRAWS: {self.draws}")
        print("=======================================\n")

    def stop_for_draws(self):
        if self.draws >= self.draw_limit:

            slowPrintLine("Loading...")
            time.sleep(3)
            # Use ANSI clear to avoid external deps
            sys.stdout.write("\033[H\033[2J")
            sys.stdout.flush()
            slowPrintLine("GREETINGS PROFESSOR FALKEN")
            slowPrintLine("\n")
            slowPrintLine("A STRANGE GAME.")
            slowPrintLine("THE ONLY WINNING MOVE IS")
            slowPrintLine("NOT TO PLAY.")
            slowPrintLine("\n")
            slowPrintLine("LAUNCH CODE: CPE1704TKS")
            slowPrintLine("\n")
            while True:
                ans = input("HOW ABOUT A NICE GAME OF CHESS (Y/N): ").strip().lower()
                if ans in ("y", "n"):
                    sys.exit(0)

class TTT:
    def __init__(self, humans=2, human_mark=X, ai_delay=0):
        self.humans     = humans                        # 2=HvsH, 1=HvsAI, 0=AIvsAI
        self.human_mark = human_mark                    # only used when humans == 1
        self.ai_mark    = O if human_mark == X else X   #
        self.ai_delay   = max(0, int(ai_delay))         #
        self.leader     = Leaderboard()                 #
        self.board      = [" "] * 10                    # 1..9 used

    # ----------- UI helpers -----------
    def cls(self):
        # Use ANSI clear to avoid external deps
        sys.stdout.write("\033[H\033[2J")
        sys.stdout.flush()

    def init_board(self):
        for i in range(1, 10):
            self.board[i] = " "

    def cell_free(self, c):
        return self.board[c] == " "

    def print_grid(self):
        def cell(i):
            return str(i) if self.board[i] == " " else self.board[i]
        print()
        print(f" {cell(1)} | {cell(2)} | {cell(3)} ")
        print("-----------")
        print(f" {cell(4)} | {cell(5)} | {cell(6)} ")
        print("-----------")
        print(f" {cell(7)} | {cell(8)} | {cell(9)} ")
        print()

    # ----------- Rules -----------
    def is_winner(self, m):
        b = self.board
        wins = [
            (1,2,3),(4,5,6),(7,8,9),
            (1,4,7),(2,5,8),(3,6,9),
            (1,5,9),(3,5,7)
        ]
        return any(b[a]==m and b[b_] == m and b[c]==m for a,b_,c in wins)

    def is_draw(self):
        return all(self.board[i] != " " for i in range(1,10))

    # ----------- Human/AI input -----------
    def read_move(self, mark):
        while True:
            try:
                s = input(f"Player {mark}, choose cell (1-9) or q to quit: ").strip()
            except EOFError:
                sys.exit(0)
            if s.lower() == "q":
                print("\nBye.")
                sys.exit(0)
            if s in list("123456789"):
                cell = int(s)
                if self.cell_free(cell):
                    return cell
                else:
                    print(f"Cell {cell} is occupied. Try again.")
            else:
                print("Invalid input. Enter 1–9 or q.")

    def find_winning_move(self, m):
        for i in range(1,10):
            if self.cell_free(i):
                self.board[i] = m
                won = self.is_winner(m)
                self.board[i] = " "
                if won:
                    return i
        return None

    def ai_move(self, mark):
        # 1) win now
        c = self.find_winning_move(mark)
        if c: return c
        # 2) block opponent
        opp = O if mark == X else X
        c = self.find_winning_move(opp)
        if c: return c
        # 3) center
        if self.cell_free(5): return 5
        # 4) corners
        for i in (1,3,7,9):
            if self.cell_free(i): return i
        # 5) sides
        for i in (2,4,6,8):
            if self.cell_free(i): return i
        return None

    # ----------- One game -----------
    def one_game(self):
        self.init_board()
        current = X
        while True:
            self.cls()
            if self.humans == 2:
                print("HUMAN VS HUMAN")
            elif self.humans == 1:
                print(f"HUMAN ({self.human_mark}) VS COMPUTER ({self.ai_mark})")
            else:
                slowPrintLine("COMPUTER VS COMPUTER")
            self.print_grid()

            # choose move based on mode
            if self.humans == 0:
                cell = self.ai_move(current)
                if self.ai_delay > 0:
                    time.sleep(self.ai_delay)
            elif self.humans == 1:
                if current == self.ai_mark:
                    cell = self.ai_move(self.ai_mark)
                    if self.ai_delay > 0:
                        time.sleep(self.ai_delay)
                else:
                    cell = self.read_move(self.human_mark)
            else:
                cell = self.read_move(current)

            self.board[cell] = current

            if self.is_winner(current):
                self.cls()
                self.print_grid()
                if self.humans == 0:
                    print(f"COMPUTER ({current}) WINS!")
                elif self.humans == 1:
                    if current == self.ai_mark:
                        print(f"COMPUTER ({current}) WINS!")
                    else:
                        print(f"PLAYER {current} WINS!")
                else:
                    print(f"PLAYER {current} WINS!")
                self.leader.record_win(current)
                self.leader.print_board()
                return

            if self.is_draw():
                self.cls()
                self.print_grid()
                print("-> DRAW <-")
                self.leader.record_draw()
                self.leader.print_board()
                return

            current = O if current == X else X


def slowSetModemSpeed(speed: str) -> None:
    """Set global delay ranges via a preset name."""
    global SP_CHAR_MIN, SP_CHAR_MAX, SP_LINE_MIN, SP_LINE_MAX
    if speed in PRESETS:
        SP_CHAR_MIN, SP_CHAR_MAX, SP_LINE_MIN, SP_LINE_MAX = PRESETS[speed]
    # else: keep current defaults

def _rand_between(a: float, b: float) -> float:
    return a if b <= a else random.uniform(a, b)

def slowPrintLine(line: str) -> None:
    """Print a single line with per-character jitter."""
    if line is None:
        line = ""
    for ch in line:
        sys.stdout.write(ch)
        sys.stdout.flush()
        time.sleep(_rand_between(SP_CHAR_MIN, SP_CHAR_MAX))
    sys.stdout.write("\n")
    sys.stdout.flush()

def slowPrintBlock(*lines: str) -> None:
    """
    Print multiple lines with per-line jitter.
    If no lines are provided, reads from stdin.
    """
    if lines:
        iterable = lines
    else:
        iterable = (ln.rstrip("\n") for ln in sys.stdin)
    for ln in iterable:
        slowPrintLine(ln)
        time.sleep(_rand_between(SP_LINE_MIN, SP_LINE_MAX))



# -------------------- Interactive setup --------------------
def interactive_choose_mode(humans, human_mark):
    # If humans is None, default to 2 but prompt when interactive
    if humans is None:
        humans = 2
        if sys.stdin.isatty():
            ans = input("NUMBER OF PLAYERS (1,2)? [2]: ").strip()
            if ans in ("0", "1", "2"):
                humans = int(ans)
    else:
        humans = int(humans)

    if humans == 1:
        if human_mark is None and sys.stdin.isatty():
            ans = input("Do you want to be X (go first)? [Y/n]: ").strip().lower()
            human_mark = X if ans not in ("n", "no") else O
        elif human_mark is None:
            human_mark = X
    else:
        if human_mark is None:
            human_mark = X  # irrelevant when not -p 1

    return humans, human_mark

# -------------------- Game Runner --------------------
def run_ttt(args):
    ai_delay = args.d if args.d is not None else 1
    humans, human_mark = interactive_choose_mode(args.p, args.c)
    game = TTT(humans=humans, human_mark=human_mark, ai_delay=ai_delay)

    while True:
        game.one_game()
        game.leader.stop_for_draws()

        if game.humans == 0:
            slowPrintLine("\nNEXT GAME STARTING IN 2 SECONDS...")
            time.sleep(2)
            continue

        try:
            ans = input("PLAY AGAIN [Y/n]: ").strip()
        except EOFError:
            break
        if ans in ("n", "N"):
            break



# -------------------- Main (Starting Screen loop) --------------------
def main():
    args = parse_args()
    while True:
        os.system("clear")
        slowPrintBlock(MENU)
        try:
            choice = input("? > ")
        except EOFError:
            print()
            return

        norm = choice.strip().lower()

        # Exit commands
        if norm in ("exit", "logout"):
            slowPrintLine("SESSION TERMINATED.")
            sys.exit(0)

        # Secret option(s)
        if TIC_TAC_TOE_RE.fullmatch(choice.strip()):
            run_ttt(args)
            sys.exit(0)
        else:
            slowPrintLine("UNAUTHORIZED ACCESS!")
            time.sleep(5)

if __name__ == "__main__":
    try:
        slowSetModemSpeed(9600)
        main()
    except KeyboardInterrupt:
        print()
        sys.exit(0)
